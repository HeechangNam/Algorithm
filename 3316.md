# 3316. [동아리 관리하기](https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWBnFuhqxE8DFAWr&categoryId=AWBnFuhqxE8DFAWr&categoryType=CODE)

## 아이디어  
* 오늘 담당자가 내일 나오고 내일 담당자가 오늘 나오기 - **X**  
즉, 예제1번의 경우  
오늘 담당자가 내일 나오는 경우 - AB BC  
내일 담당자가 오늘 나오는 경우 - ABC C  
그리고 중복의 경우 - ABC BC를 빼면 된다!  
  
  CD가 있고 없고, AD가 있고 없고 -> (2^2)*(2^2) = 16  
  D가 있고 없고, ABD가 있고 없고 -> 2 * (2^3) = 16  
  D가 있고 없고, AD가 있고 없고 -> 2 * (2^2) = 8  
  = 24  
    
    담당자가 **꼭** 나올 필요가 없다! ABD CD의 경우가 가능함.
    
* 관리자는 있는 전체의 수 중에서 전날 있던 사람이 안나오는 경우  
다시 예제1번의 경우  
첫날 AB가 있는 경우  
둘쨋날 C가 있는 경우  
이 때 전날 있던 사람이 없을 경우  
  
  CD가 있고 없고 -> 2^2 = 4  
  ABD가 있고 없고 -> (2^3) = 8  
  전날 있던 사람이 없을 때  
  AB인 경우 -> C, CD  
  ABC - x  
  ABD - C  
  ABCD - x  
  4*8 - 3 = 29  
    
    * 있던 사람이 없는 경우를 빼내는 법 - **X**  
    전날에 당일 담당자가 나오지 않는 경우를 구함 -> 그 경우에 대해 있는 것이 확실한 경우를 제외한다.  
    예제1번의 경우,  
    첫날에 C가 나오지 않는 경우 - AB가 있고 C가 없고 D가 있고없고 -> 2  
    첫날 D가 없을때, 둘쨋날 D가 있고없고 -> 2  
    첫날 D가 있을때, 둘쨋날 ABD가 없고, C만 있는경우 -> 1  
    따라서 3  
      
      예제2번의 이틀까지의 경우,  
      첫날에 D가 나오지 않는 경우 - A가 있고 D가 없고 BC가 있고없고 -> 4  
      첫날 B가 없고 C가 있을때, 둘쨋날 B가 있고없고 -> 2  
      첫날 C가 없고 B가 있을때, 둘쨋날 C가 있고없고 -> 2  
      첫날 BC가 없을때, 둘쨋날 BC가 있고없고 -> 4  
      첫날 BC가 있을때, 둘쨋날 ABC가 없고 D만 있는 경우 - 1  
      따라서 9  
* **결국 혼자풀기 실패ㅠ**

## 코드이해  
* 아이디어  
전체 경우의 수 중에서, 당일의 관리자가 포함되어 있으며 전날에 있던 사람이 한사람이라도 있는 경우만 골라내기!  
내가 생각한 아이디어는 우선 관리자가 있는 모든 경우를 계산하고, 그 중에서 전날의 경우에 맞게 빼는 거였지만  
이 아이디어의 경우 그냥 가능한한 모든 경우의 수를 다 살펴보고 맞는 걸 골라낸다.  
  
* 구현
  * 사용한 자료구조 : 변수 dp[10001][16]를 가지고 계산한다. 이 때 dp[i][j]는 i번째의 날에 j의 경우에 가능한 경우의 수를 저장한다.  
  이 때, j는 2진법으로 생각하는데 만약 j가 3 즉 0011(2)일 때 j는 오늘 참석한 동아리원이 AB일 때를 가정한다는 의미를 가진다.  
  
  * 첫째날에 A가 무조건 있어야 한다는 조건 : dp[0][1] = 1로 set하고 알고리즘을 돌린다.  
  
  * 담당자는 director = 1 << str[day - 1]-'A'의 형태로 director 변수에 지정된다.  
  즉 담당자가 A일 경우 0001(2), B일 경우 0010(2), C일 경우 0100(2), D일 경우 1000(2)의 꼴이다.  
  
  * 아이디어 구현  
    ```
    if ((i & director) > 0 && (i & j) > 0) {
      dp[day][i] += dp[day - 1][j];
      dp[day][i] %= 1000000007;
    }
    ```  
    i와 j는 1~16까지의 정수값을 가지며 가능한 경우를 나타내며 각각 i는 오늘 가능한 경우, j는 어제의 경우를 의미한다.  
    &연산을 통해 동일한 인자를 포함할 때 1보다 큰 결과값을 얻는다.  
    예를 들어 오늘 담당자는 C고 현재 ABC의 경우를 살펴본다고 했을 때,  
    i의 값은 0111(2)이고 director의 값은 0100(2)이며, 연산의 결과값은 0100(2)가 된다.  
    마찬가지로 현재 오늘이 AB의 경우고 어제가 BC인 경우를 살펴본다고 했을 때,
    i의 값은 0011(2)이고 j의 값은 1100(2)이며, 연산의 결과값은 0000(2)가 된다.  
  
    i가 오늘 담당자를 포함한 가능한 경우이고, j와 i가 겹치는 사람이 있을 때, 어제의 해당 경우의 값을 오늘에 더해주게 된다.  
    따라서 맨 마지막 날, dp[day-1][1]부터 dp[day-1][15]까지의 모든 수를 더하고 1000000007로 나누어 주면 답이 나온다.


    
  
